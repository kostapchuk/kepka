name: Release from Branch

on:
  push:
    branches:
      - 'release/*'

env:
  NODE_VERSION: '18'

jobs:
  # Your existing CI pipeline
  build:
    name: Install and Build
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v4.2.2

      - name: Setup node dependencies
        uses: ./.github/actions/setup-node-deps

      - name: Build the app
        run: npm run build

      - name: Save build folder
        uses: actions/upload-artifact@v4
        with:
          name: build
          if-no-files-found: error
          path: build

  unit-tests:
    name: Run unit tests
    runs-on: ubuntu-22.04
    needs: build
    steps:
      - uses: actions/checkout@v4.2.2

      - name: Setup node dependencies
        uses: ./.github/actions/setup-node-deps

      - name: Run unit tests
        run: npm test -- --ci --coverage

  cypress-tests:
    name: Run cypress tests
    runs-on: ubuntu-22.04
    needs: [ build, unit-tests ]
    env:
      TESTOMATIO: ${{ secrets.TESTOMATIO_API_KEY }}
    steps:
      - uses: actions/checkout@v4.2.2

      - name: Setup node dependencies
        uses: ./.github/actions/setup-node-deps

      - name: Download the build folder
        uses: actions/download-artifact@v4.3.0
        with:
          name: build
          path: build

      - name: Start app and run Cypress with Testomat reporting
        uses: cypress-io/github-action@v6
        with:
          start: npm start
          browser: chrome
          wait-on: 'http://localhost:3000'
          wait-on-timeout: 120
        env:
          TESTOMATIO: ${{ secrets.TESTOMATIO_API_KEY }}

  # Release-specific steps that run after all tests pass
  create-release:
    name: Create Release and Tag
    needs: [ build, unit-tests, cypress-tests ]
    runs-on: ubuntu-22.04
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Extract version from branch name
        id: extract_version
        run: |
          BRANCH_NAME="${{ github.ref_name }}"
          VERSION=${BRANCH_NAME#release/}
          echo "Extracted version: $VERSION"
          
          # Validate version format (X.Y.Z)
          if [[ ! $VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "❌ Invalid version format. Expected X.Y.Z, got: $VERSION"
            exit 1
          fi
          
          # Split version into components
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"
          echo "major=$MAJOR" >> $GITHUB_OUTPUT
          echo "minor=$MINOR" >> $GITHUB_OUTPUT
          echo "patch=$PATCH" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          
          # Calculate next minor version for main branch
          NEXT_MINOR=$((MINOR + 1))
          echo "next_minor=$NEXT_MINOR" >> $GITHUB_OUTPUT
          echo "next_version=$MAJOR.$NEXT_MINOR.0" >> $GITHUB_OUTPUT

      - name: Checkout release branch
        uses: actions/checkout@v4.2.2
        with:
          fetch-depth: 0
          ref: ${{ github.ref_name }}

      - name: Setup node dependencies
        uses: ./.github/actions/setup-node-deps

      - name: Validate package.json version matches branch
        id: validate_version
        run: |
          PACKAGE_VERSION=$(node -p "require('./package.json').version")
          echo "Package version: $PACKAGE_VERSION"
          echo "Branch version: ${{ steps.extract_version.outputs.version }}"
          
          if [ "$PACKAGE_VERSION" != "${{ steps.extract_version.outputs.version }}" ]; then
            echo "❌ Version mismatch! package.json has $PACKAGE_VERSION, branch expects ${{ steps.extract_version.outputs.version }}"
            exit 1
          fi
          
          echo "✅ Version validation passed"

      - name: Create Git tag
        run: |
          git tag v${{ steps.extract_version.outputs.version }}
          git push origin v${{ steps.extract_version.outputs.version }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.extract_version.outputs.version }}
          name: Release v${{ steps.extract_version.outputs.version }}
          draft: false
          prerelease: false
          generate_release_notes: true
          body: |
            ## Release v${{ steps.extract_version.outputs.version }}
            
            ✅ All tests passed:
            - ✅ Build completed successfully
            - ✅ Unit tests passed with coverage
            - ✅ Cypress E2E tests passed
            
            ### Artifacts
            The build artifacts are available in the build job outputs.
            
            ### Changes since last release
            See commit history for details.

      - name: Update version on main branch
        id: update_main
        run: |
          # Switch to main branch
          git fetch origin main
          git checkout main
          git pull origin main
          
          # Get current version from main
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          echo "Current main version: $CURRENT_VERSION"
          echo "Release version: ${{ steps.extract_version.outputs.version }}"
          echo "Next version: ${{ steps.extract_version.outputs.next_version }}"
          
          # Only update if main version is NOT already the next version
          # This prevents duplicate updates if the workflow runs multiple times
          if [[ "$CURRENT_VERSION" != "${{ steps.extract_version.outputs.next_version }}" ]]; then
            # Clean approach
            echo "Cleaning up existing dependencies..."
            rm -rf node_modules
            rm -f package-lock.json
          
            # Update package.json version to next minor version
            echo "Updating package.json to version ${{ steps.extract_version.outputs.next_version }}..."
            npm version ${{ steps.extract_version.outputs.next_version }} --no-git-tag-version
          
            # Create fresh lock file with new version
            echo "Creating fresh package-lock.json..."
            npm install --package-lock-only
          
            # Verify versions match
            PACKAGE_VERSION=$(node -p "require('./package.json').version")
            LOCK_VERSION=$(node -p "require('./package-lock.json').version")
          
            if [ "$PACKAGE_VERSION" != "$LOCK_VERSION" ]; then
              echo "❌ Version mismatch after update!"
              echo "package.json: $PACKAGE_VERSION"
              echo "package-lock.json: $LOCK_VERSION"
              exit 1
            fi
          
            echo "✅ Version updated to: $PACKAGE_VERSION"
          
            # Commit changes
            git add package.json package-lock.json
            git commit -m "chore: bump version to ${{ steps.extract_version.outputs.next_version }}
          
            - Update package.json version to ${{ steps.extract_version.outputs.next_version }}
            - Regenerate package-lock.json
            [skip ci]"
          
            git push origin main
          
            echo "✅ Successfully updated main branch to ${{ steps.extract_version.outputs.next_version }}"
          else
            echo "✅ Main branch already at version ${{ steps.extract_version.outputs.next_version }}, no update needed"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}